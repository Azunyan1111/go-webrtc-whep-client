diff --git a/Makefile b/Makefile
index 00e567c..8106446 100644
--- a/Makefile
+++ b/Makefile
@@ -39,10 +39,10 @@ WRAPPER_OBJ := $(WRAPPER_DIR)/webrtc_objc_wrapper.o
 WRAPPER_LIB := $(WRAPPER_DIR)/libwebrtc_objc_wrapper.a
 
 # libwebrtc download URL (shiguredo-webrtc-build)
-LIBWEBRTC_VERSION := m120.0.6099.129
-LIBWEBRTC_URL_MACOS_ARM64 := https://github.com/AzuCLR/libwebrtc-build/releases/download/$(LIBWEBRTC_VERSION)/libwebrtc-macos-arm64-$(LIBWEBRTC_VERSION).tar.gz
-LIBWEBRTC_URL_MACOS_X64 := https://github.com/AzuCLR/libwebrtc-build/releases/download/$(LIBWEBRTC_VERSION)/libwebrtc-macos-x86_64-$(LIBWEBRTC_VERSION).tar.gz
-LIBWEBRTC_URL_LINUX_X64 := https://github.com/AzuCLR/libwebrtc-build/releases/download/$(LIBWEBRTC_VERSION)/libwebrtc-ubuntu-x86_64-$(LIBWEBRTC_VERSION).tar.gz
+LIBWEBRTC_VERSION := m144.7559.2.1
+LIBWEBRTC_URL_BASE := https://github.com/shiguredo-webrtc-build/webrtc-build/releases/download/$(LIBWEBRTC_VERSION)
+LIBWEBRTC_URL_MACOS_ARM64 := $(LIBWEBRTC_URL_BASE)/webrtc.macos_arm64.tar.gz
+LIBWEBRTC_URL_LINUX_X64 := $(LIBWEBRTC_URL_BASE)/webrtc.ubuntu-24.04_x86_64.tar.gz
 
 # C++ compiler flags for libwebrtc wrapper
 CXX := c++
@@ -111,36 +111,49 @@ $(LIBWEBRTC_CONFIG_SITE):
 	@echo "Run 'make download-libwebrtc' to download it"
 	@exit 1
 
-# Download libwebrtc (macOS arm64)
+# __config_site content for ABI compatibility
+define CONFIG_SITE_CONTENT
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef _LIBCPP___CONFIG_SITE
+#define _LIBCPP___CONFIG_SITE
+
+#define _LIBCPP_ABI_VERSION 2
+#define _LIBCPP_ABI_NAMESPACE __Cr
+
+#define _LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS
+#define _LIBCPP_HAS_NO_VENDOR_AVAILABILITY_ANNOTATIONS
+
+#endif // _LIBCPP___CONFIG_SITE
+endef
+export CONFIG_SITE_CONTENT
+
+# Download libwebrtc for all supported platforms
 download-libwebrtc:
-ifeq ($(UNAME_S),Darwin)
-ifeq ($(UNAME_M),arm64)
-	@echo "Downloading libwebrtc for macOS arm64..."
+	@echo "Downloading libwebrtc $(LIBWEBRTC_VERSION) for macOS arm64..."
 	@mkdir -p $(LIBWEBRTC_DIR)
-	curl -L -o /tmp/libwebrtc.tar.gz $(LIBWEBRTC_URL_MACOS_ARM64)
-	tar xzf /tmp/libwebrtc.tar.gz -C $(LIBWEBRTC_DIR)
-	rm /tmp/libwebrtc.tar.gz
+	curl -L -o /tmp/libwebrtc-macos.tar.gz $(LIBWEBRTC_URL_MACOS_ARM64)
+	tar xzf /tmp/libwebrtc-macos.tar.gz -C $(LIBWEBRTC_DIR)
+	rm /tmp/libwebrtc-macos.tar.gz
+	@rm -rf $(LIBWEBRTC_DIR)/webrtc/Frameworks
+	@mkdir -p $(LIBWEBRTC_DIR)/webrtc/include/buildtools/third_party/libc++
+	@echo "$$CONFIG_SITE_CONTENT" > $(LIBWEBRTC_DIR)/webrtc/include/buildtools/third_party/libc++/__config_site
 	@echo "Downloaded to $(LIBWEBRTC_DIR)"
-else
-	@echo "Downloading libwebrtc for macOS x86_64..."
-	@mkdir -p webrtc-macos-x86_64
-	curl -L -o /tmp/libwebrtc.tar.gz $(LIBWEBRTC_URL_MACOS_X64)
-	tar xzf /tmp/libwebrtc.tar.gz -C webrtc-macos-x86_64
-	rm /tmp/libwebrtc.tar.gz
-	@echo "Downloaded to webrtc-macos-x86_64"
-	@echo "NOTE: Update LIBWEBRTC_DIR in Makefile or cgo_darwin_amd64.go"
-endif
-else ifeq ($(UNAME_S),Linux)
-	@echo "Downloading libwebrtc for Linux x86_64..."
+	@echo ""
+	@echo "Downloading libwebrtc $(LIBWEBRTC_VERSION) for Linux x86_64..."
 	@mkdir -p webrtc-ubuntu-x86_64
-	curl -L -o /tmp/libwebrtc.tar.gz $(LIBWEBRTC_URL_LINUX_X64)
-	tar xzf /tmp/libwebrtc.tar.gz -C webrtc-ubuntu-x86_64
-	rm /tmp/libwebrtc.tar.gz
+	curl -L -o /tmp/libwebrtc-linux.tar.gz $(LIBWEBRTC_URL_LINUX_X64)
+	tar xzf /tmp/libwebrtc-linux.tar.gz -C webrtc-ubuntu-x86_64
+	rm /tmp/libwebrtc-linux.tar.gz
+	@mkdir -p webrtc-ubuntu-x86_64/webrtc/include/buildtools/third_party/libc++
+	@echo "$$CONFIG_SITE_CONTENT" > webrtc-ubuntu-x86_64/webrtc/include/buildtools/third_party/libc++/__config_site
 	@echo "Downloaded to webrtc-ubuntu-x86_64"
-else
-	@echo "ERROR: Unsupported platform $(UNAME_S) $(UNAME_M)"
-	@exit 1
-endif
 
 # Format Go code
 fmt:
@@ -162,7 +175,7 @@ clean:
 
 # Clean everything including libwebrtc downloads
 clean-all: clean
-	rm -rf webrtc-macos-arm64 webrtc-macos-x86_64 webrtc-ubuntu-x86_64
+	rm -rf webrtc-macos-arm64 webrtc-ubuntu-x86_64
 	rm -f /tmp/libwebrtc.tar.gz
 
 # Rebuild libwebrtc wrapper from scratch
diff --git a/cmd/whep-libwebrtc-go/main.go b/cmd/whep-libwebrtc-go/main.go
index 7bede61..1392bdd 100644
--- a/cmd/whep-libwebrtc-go/main.go
+++ b/cmd/whep-libwebrtc-go/main.go
@@ -124,8 +124,8 @@ func run() error {
 				}
 			}
 		},
-		OnEncodedAudioFrame: func(frame *libwebrtc.EncodedAudioFrame) {
-			if err := mkvWriter.WriteEncodedAudioFrame(frame); err != nil {
+		OnAudioFrame: func(frame *libwebrtc.AudioFrame) {
+			if err := mkvWriter.WriteAudioFrame(frame); err != nil {
 				if debugMode {
 					fmt.Fprintf(os.Stderr, "Audio write error: %v\n", err)
 				}
diff --git a/internal/libwebrtc/callbacks.go b/internal/libwebrtc/callbacks.go
index 2f22114..b183ec8 100644
--- a/internal/libwebrtc/callbacks.go
+++ b/internal/libwebrtc/callbacks.go
@@ -64,22 +64,34 @@ func goOnVideoFrame(userData C.uintptr_t,
 	cb.OnVideoFrame(frame)
 }
 
-//export goOnEncodedAudio
-func goOnEncodedAudio(userData C.uintptr_t,
-	data *C.uint8_t, dataLen C.int,
-	timestamp C.uint32_t, sequenceNumber C.uint16_t) {
+//export goOnAudioData
+func goOnAudioData(userData C.uintptr_t,
+	data *C.int16_t, sampleRate C.int,
+	channels C.int, frames C.int, timestampUs C.int64_t) {
 
 	id := uintptr(userData)
 	cb := getCallbacks(id)
-	if cb == nil || cb.OnEncodedAudioFrame == nil {
+	if cb == nil || cb.OnAudioFrame == nil {
 		return
 	}
 
-	frame := &EncodedAudioFrame{
-		Data:           C.GoBytes(unsafe.Pointer(data), dataLen),
-		Timestamp:      uint32(timestamp),
-		SequenceNumber: uint16(sequenceNumber),
+	// Calculate total samples
+	numSamples := int(frames) * int(channels)
+
+	// Copy PCM data to Go slice
+	pcmData := make([]int16, numSamples)
+	src := (*[1 << 28]C.int16_t)(unsafe.Pointer(data))[:numSamples:numSamples]
+	for i := 0; i < numSamples; i++ {
+		pcmData[i] = int16(src[i])
+	}
+
+	frame := &AudioFrame{
+		PCM:         pcmData,
+		SampleRate:  int(sampleRate),
+		Channels:    int(channels),
+		Frames:      int(frames),
+		TimestampUs: int64(timestampUs),
 	}
 
-	cb.OnEncodedAudioFrame(frame)
+	cb.OnAudioFrame(frame)
 }
diff --git a/internal/libwebrtc/libwebrtc.go b/internal/libwebrtc/libwebrtc.go
index 18aaf07..2183a44 100644
--- a/internal/libwebrtc/libwebrtc.go
+++ b/internal/libwebrtc/libwebrtc.go
@@ -13,9 +13,9 @@ void goOnVideoFrame(uintptr_t userData,
     const uint8_t* dataU, int strideU,
     const uint8_t* dataV, int strideV,
     int width, int height, int64_t timestamp_us);
-void goOnEncodedAudio(uintptr_t userData,
-    const uint8_t* data, int dataLen,
-    uint32_t timestamp, uint16_t sequenceNumber);
+void goOnAudioData(uintptr_t userData,
+    const int16_t* data, int sampleRate,
+    int channels, int frames, int64_t timestamp_us);
 */
 import "C"
 
@@ -103,19 +103,12 @@ type AudioFrame struct {
 	TimestampUs int64 // Timestamp in microseconds
 }
 
-// EncodedAudioFrame represents an encoded Opus audio frame
-type EncodedAudioFrame struct {
-	Data           []byte
-	Timestamp      uint32 // RTP timestamp (48kHz for Opus)
-	SequenceNumber uint16
-}
-
 // Callbacks holds callback functions for a PeerConnection
 type Callbacks struct {
 	OnICEConnectionState func(ICEConnectionState)
 	OnICEGatheringState  func(ICEGatheringState)
 	OnVideoFrame         func(*VideoFrame)
-	OnEncodedAudioFrame  func(*EncodedAudioFrame)
+	OnAudioFrame         func(*AudioFrame)
 }
 
 // Global callback registry
@@ -196,7 +189,7 @@ func NewPeerConnection(factory *Factory, stunServer string, callbacks *Callbacks
 		C.OnICEStateCallback(C.goOnICEState),
 		C.OnICEGatheringStateCallback(C.goOnICEGathering),
 		C.OnVideoFrameCallback(C.goOnVideoFrame),
-		C.OnEncodedAudioCallback(C.goOnEncodedAudio),
+		C.OnAudioDataCallback(C.goOnAudioData),
 	)
 
 	if handle == nil {
diff --git a/internal/libwebrtc/libwebrtc_objc_wrapper.a b/internal/libwebrtc/libwebrtc_objc_wrapper.a
index d2efdca..5001be6 100644
Binary files a/internal/libwebrtc/libwebrtc_objc_wrapper.a and b/internal/libwebrtc/libwebrtc_objc_wrapper.a differ
diff --git a/internal/libwebrtc/webrtc_objc_wrapper.h b/internal/libwebrtc/webrtc_objc_wrapper.h
index db1d1e9..4e9dba5 100644
--- a/internal/libwebrtc/webrtc_objc_wrapper.h
+++ b/internal/libwebrtc/webrtc_objc_wrapper.h
@@ -41,9 +41,9 @@ typedef void (*OnVideoFrameCallback)(uintptr_t userData,
     const uint8_t* dataU, int strideU,
     const uint8_t* dataV, int strideV,
     int width, int height, int64_t timestamp_us);
-typedef void (*OnEncodedAudioCallback)(uintptr_t userData,
-    const uint8_t* data, int dataLen,
-    uint32_t timestamp, uint16_t sequenceNumber);
+typedef void (*OnAudioDataCallback)(uintptr_t userData,
+    const int16_t* data, int sampleRate,
+    int channels, int frames, int64_t timestamp_us);
 
 // Factory functions
 WebRTCFactoryHandle webrtc_objc_factory_create(void);
@@ -57,7 +57,7 @@ PeerConnectionHandle webrtc_objc_pc_create(
     OnICEStateCallback onICEState,
     OnICEGatheringStateCallback onICEGathering,
     OnVideoFrameCallback onVideoFrame,
-    OnEncodedAudioCallback onEncodedAudio
+    OnAudioDataCallback onAudioData
 );
 
 int webrtc_objc_pc_add_video_transceiver(PeerConnectionHandle pc);
diff --git a/internal/libwebrtc/webrtc_objc_wrapper.mm b/internal/libwebrtc/webrtc_objc_wrapper.mm
index 94c3c32..b963ec6 100644
--- a/internal/libwebrtc/webrtc_objc_wrapper.mm
+++ b/internal/libwebrtc/webrtc_objc_wrapper.mm
@@ -30,7 +30,6 @@
 #include "rtc_base/thread.h"
 #include "rtc_base/ref_counted_object.h"
 #include "libyuv/convert_argb.h"
-#include "api/frame_transformer_interface.h"
 
 namespace {
 
@@ -115,52 +114,44 @@ private:
     OnVideoFrameCallback callback_;
 };
 
-// Audio frame transformer implementation for encoded Opus passthrough
-class AudioFrameTransformer : public webrtc::FrameTransformerInterface {
+// Audio sink implementation for decoded PCM audio
+class AudioSinkImpl : public webrtc::AudioTrackSinkInterface {
 public:
-    AudioFrameTransformer(uintptr_t userData, OnEncodedAudioCallback callback)
+    AudioSinkImpl(uintptr_t userData, OnAudioDataCallback callback)
         : userData_(userData), callback_(callback) {}
 
-    void Transform(std::unique_ptr<webrtc::TransformableFrameInterface> frame) override {
-        if (callback_) {
-            auto* audio_frame = static_cast<webrtc::TransformableAudioFrameInterface*>(frame.get());
-            auto data = frame->GetData();
-            auto seqNum = audio_frame->SequenceNumber();
-
-            // Debug: log first few bytes and size (only first 50 frames)
-            static int debug_count = 0;
-            if (debug_count < 50) {
-                fprintf(stderr, "[AudioFrameTransformer] Frame size=%zu, timestamp=%u, seq=%u, first bytes:",
-                        data.size(), frame->GetTimestamp(), seqNum.value_or(0));
-                for (size_t i = 0; i < std::min(data.size(), size_t(16)); i++) {
-                    fprintf(stderr, " %02x", data.data()[i]);
-                }
-                fprintf(stderr, "\n");
-                fflush(stderr);
-                debug_count++;
-            }
-
-            callback_(userData_,
-                data.data(), static_cast<int>(data.size()),
-                frame->GetTimestamp(),
-                seqNum.value_or(0));
+    void OnData(const void* audio_data,
+                int bits_per_sample,
+                int sample_rate,
+                size_t number_of_channels,
+                size_t number_of_frames,
+                std::optional<int64_t> absolute_capture_timestamp_ms) override {
+        if (!callback_) return;
+
+        // libwebrtc always provides 16-bit PCM
+        if (bits_per_sample != 16) {
+            return;
         }
-        // Do not forward to decoder - skip PCM decoding
-    }
 
-    void RegisterTransformedFrameSinkCallback(
-        webrtc::scoped_refptr<webrtc::TransformedFrameCallback> callback,
-        uint32_t ssrc) override {
-        // Not used - we don't forward frames to decoder
-    }
+        const int16_t* pcm_data = static_cast<const int16_t*>(audio_data);
 
-    void UnregisterTransformedFrameSinkCallback(uint32_t ssrc) override {
-        // Not used
+        // Convert timestamp to microseconds
+        int64_t timestamp_us = 0;
+        if (absolute_capture_timestamp_ms.has_value()) {
+            timestamp_us = absolute_capture_timestamp_ms.value() * 1000;
+        }
+
+        callback_(userData_,
+            pcm_data,
+            sample_rate,
+            static_cast<int>(number_of_channels),
+            static_cast<int>(number_of_frames),
+            timestamp_us);
     }
 
 private:
     uintptr_t userData_;
-    OnEncodedAudioCallback callback_;
+    OnAudioDataCallback callback_;
 };
 
 // Create SDP Observer
@@ -264,13 +255,13 @@ public:
         OnICEStateCallback onICEState,
         OnICEGatheringStateCallback onICEGathering,
         OnVideoFrameCallback onVideoFrame,
-        OnEncodedAudioCallback onEncodedAudio)
+        OnAudioDataCallback onAudioData)
         : factory_(factory)
         , userData_(userData)
         , onICEState_(onICEState)
         , onICEGathering_(onICEGathering)
         , videoSink_(new VideoSinkImpl(userData, onVideoFrame))
-        , audioFrameTransformer_(webrtc::make_ref_counted<AudioFrameTransformer>(userData, onEncodedAudio)) {
+        , audioSink_(new AudioSinkImpl(userData, onAudioData)) {
 
         webrtc::PeerConnectionInterface::RTCConfiguration config;
         config.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;
@@ -328,10 +319,10 @@ public:
             video_track->AddOrUpdateSink(videoSink_.get(), wants);
             NSLog(@"[OnTrack] Video sink added");
         } else if (track->kind() == webrtc::MediaStreamTrackInterface::kAudioKind) {
-            // Use FrameTransformer to get encoded Opus frames
-            NSLog(@"[OnTrack] Setting audio FrameTransformer");
-            transceiver->receiver()->SetFrameTransformer(audioFrameTransformer_);
-            NSLog(@"[OnTrack] Audio FrameTransformer set");
+            // Use AudioSinkInterface to get decoded PCM audio
+            auto audio_track = static_cast<webrtc::AudioTrackInterface*>(track.get());
+            audio_track->AddSink(audioSink_.get());
+            NSLog(@"[OnTrack] Audio sink added");
         }
     }
 
@@ -342,7 +333,7 @@ private:
     OnICEStateCallback onICEState_;
     OnICEGatheringStateCallback onICEGathering_;
     std::unique_ptr<VideoSinkImpl> videoSink_;
-    webrtc::scoped_refptr<AudioFrameTransformer> audioFrameTransformer_;
+    std::unique_ptr<AudioSinkImpl> audioSink_;
 };
 
 }  // namespace
@@ -374,7 +365,7 @@ PeerConnectionHandle webrtc_objc_pc_create(
     OnICEStateCallback onICEState,
     OnICEGatheringStateCallback onICEGathering,
     OnVideoFrameCallback onVideoFrame,
-    OnEncodedAudioCallback onEncodedAudio) {
+    OnAudioDataCallback onAudioData) {
 
     @autoreleasepool {
         if (!factory) return nullptr;
@@ -386,7 +377,7 @@ PeerConnectionHandle webrtc_objc_pc_create(
             onICEState,
             onICEGathering,
             onVideoFrame,
-            onEncodedAudio
+            onAudioData
         );
 
         if (!wrapper->valid()) {
diff --git a/internal/libwebrtc/webrtc_objc_wrapper.o b/internal/libwebrtc/webrtc_objc_wrapper.o
index 694b362..2f77758 100644
Binary files a/internal/libwebrtc/webrtc_objc_wrapper.o and b/internal/libwebrtc/webrtc_objc_wrapper.o differ
diff --git a/internal/mkvwriter/encoded_mkv_writer.go b/internal/mkvwriter/encoded_mkv_writer.go
index 7c1c70c..bdd1ae1 100644
--- a/internal/mkvwriter/encoded_mkv_writer.go
+++ b/internal/mkvwriter/encoded_mkv_writer.go
@@ -14,7 +14,7 @@ import (
 	"github.com/Azunyan1111/go-webrtc-whep-client/internal/libwebrtc"
 )
 
-// codecPrivate is a placeholder for Opus CodecPrivate element
+// EBML element IDs (additional for this file)
 const (
 	codecPrivate = 0x63A2
 )
@@ -32,9 +32,8 @@ type EncodedMKVWriter struct {
 	videoTrackNum   uint64
 	audioTrackNum   uint64
 	clusterTime     uint64
-	// Separate base timestamps for video and audio
+	// Base timestamps for video and audio
 	videoBaseTs  int64
-	audioBaseTs  uint32 // RTP timestamp (48kHz)
 	hasVideoBase bool
 	hasAudioBase bool
 	// Wall clock time for synchronization
@@ -118,9 +117,9 @@ func (w *EncodedMKVWriter) WriteVideoFrame(frame *libwebrtc.VideoFrame) error {
 	return w.writeSimpleBlock(w.videoTrackNum, rgba, timecodeMs, keyframe)
 }
 
-// WriteEncodedAudioFrame writes an encoded Opus audio frame
-func (w *EncodedMKVWriter) WriteEncodedAudioFrame(frame *libwebrtc.EncodedAudioFrame) error {
-	if frame == nil || len(frame.Data) == 0 {
+// WriteAudioFrame writes a decoded PCM audio frame
+func (w *EncodedMKVWriter) WriteAudioFrame(frame *libwebrtc.AudioFrame) error {
+	if frame == nil || len(frame.PCM) == 0 {
 		return nil
 	}
 
@@ -135,23 +134,37 @@ func (w *EncodedMKVWriter) WriteEncodedAudioFrame(frame *libwebrtc.EncodedAudioF
 		return nil
 	}
 
-	// Initialize base timestamp and wall clock time
+	// Update sample rate and channels from actual frame if different
+	if frame.SampleRate != w.sampleRate || frame.Channels != w.audioChannels {
+		// Note: In a real implementation, we might need to handle sample rate changes
+		// For now, we assume the first frame sets the correct values
+		if !w.hasAudioBase {
+			w.sampleRate = frame.SampleRate
+			w.audioChannels = frame.Channels
+		}
+	}
+
+	// Initialize wall clock time for synchronization
 	if !w.hasAudioBase {
-		w.audioBaseTs = frame.Timestamp
 		w.hasAudioBase = true
-		// Use wall clock for synchronization if this is the first frame
 		if w.startWallTime == 0 {
 			w.startWallTime = time.Now().UnixMicro()
 		}
-		DebugLog("Base audio RTP timestamp: %d, wall time: %d us\n", w.audioBaseTs, w.startWallTime)
+		DebugLog("Audio started: %d Hz, %d channels, wall time: %d us\n",
+			frame.SampleRate, frame.Channels, w.startWallTime)
 	}
 
 	// Calculate timecode in milliseconds using wall clock time for sync
 	wallElapsed := time.Now().UnixMicro() - w.startWallTime
 	timecodeMs := uint64(wallElapsed / 1000)
 
-	// Write Opus frame directly (no re-encoding needed)
-	return w.writeSimpleBlock(w.audioTrackNum, frame.Data, timecodeMs, false)
+	// Convert PCM int16 to bytes (little-endian)
+	pcmBytes := make([]byte, len(frame.PCM)*2)
+	for i, sample := range frame.PCM {
+		binary.LittleEndian.PutUint16(pcmBytes[i*2:], uint16(sample))
+	}
+
+	return w.writeSimpleBlock(w.audioTrackNum, pcmBytes, timecodeMs, false)
 }
 
 // Run starts the main loop
@@ -309,7 +322,7 @@ func (w *EncodedMKVWriter) writeTracks() error {
 		return err
 	}
 
-	// Audio track - A_OPUS (encoded Opus)
+	// Audio track - A_PCM/INT/LIT (PCM signed 16-bit little-endian)
 	audioEntry := &bytes.Buffer{}
 	if err := w.writeEBMLElement(audioEntry, trackNumber, w.encodeUInt(w.audioTrackNum)); err != nil {
 		return err
@@ -320,14 +333,7 @@ func (w *EncodedMKVWriter) writeTracks() error {
 	if err := w.writeEBMLElement(audioEntry, trackType, []byte{trackTypeAudio}); err != nil {
 		return err
 	}
-	if err := w.writeEBMLElement(audioEntry, codecID, []byte("A_OPUS")); err != nil {
-		return err
-	}
-
-	// CodecPrivate - OpusHead (Opus Identification Header)
-	// See: https://wiki.xiph.org/OggOpus#ID_Header
-	opusHead := w.buildOpusHead()
-	if err := w.writeEBMLElement(audioEntry, codecPrivate, opusHead); err != nil {
+	if err := w.writeEBMLElement(audioEntry, codecID, []byte("A_PCM/INT/LIT")); err != nil {
 		return err
 	}
 
@@ -339,6 +345,10 @@ func (w *EncodedMKVWriter) writeTracks() error {
 	if err := w.writeEBMLElement(audioSettings, channels, w.encodeUInt(uint64(w.audioChannels))); err != nil {
 		return err
 	}
+	// BitDepth - 16 bits per sample
+	if err := w.writeEBMLElement(audioSettings, bitDepth, w.encodeUInt(16)); err != nil {
+		return err
+	}
 	if err := w.writeEBMLElement(audioEntry, audio, audioSettings.Bytes()); err != nil {
 		return err
 	}
@@ -351,27 +361,6 @@ func (w *EncodedMKVWriter) writeTracks() error {
 	return w.writeEBMLElement(w.writer, tracks, tracksData.Bytes())
 }
 
-// buildOpusHead creates an OpusHead (Opus Identification Header)
-// Format: https://wiki.xiph.org/OggOpus#ID_Header
-func (w *EncodedMKVWriter) buildOpusHead() []byte {
-	head := make([]byte, 19)
-	// Magic signature "OpusHead"
-	copy(head[0:8], []byte("OpusHead"))
-	// Version (1)
-	head[8] = 1
-	// Channel count
-	head[9] = byte(w.audioChannels)
-	// Pre-skip (little-endian uint16) - typically 312 samples for WebRTC
-	binary.LittleEndian.PutUint16(head[10:12], 312)
-	// Input sample rate (little-endian uint32) - original sample rate
-	binary.LittleEndian.PutUint32(head[12:16], uint32(w.sampleRate))
-	// Output gain (little-endian int16) - 0 dB
-	binary.LittleEndian.PutUint16(head[16:18], 0)
-	// Channel mapping family (0 = mono/stereo, no mapping table)
-	head[18] = 0
-	return head
-}
-
 func (w *EncodedMKVWriter) writeSimpleBlock(trackNum uint64, data []byte, timecodeMs uint64, keyframe bool) error {
 	// Start new cluster on keyframe or every second
 	needNewCluster := false
